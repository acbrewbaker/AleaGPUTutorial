# Fast N-Body Simulation with Alea GPU & OpenGL

In this example introduces an implementation of the N-Body problem, i.e. the simulation of Newton’s equations for many bodies or particles. It is a problem that can be solved analytically for two particles, but in general has no analytical solution for N>2.

N-Body simulations are often used in astronomy, where particles mostly represent stars (but might also represent parts of a planet as in [impact studies](https://www.youtube.com/watch?v=Fwl_JBQtH9o) resulting in moon formation) and the interacting forces are the classical Newtonian gravitational forces. Hence formation of galaxies can be studied.

In physics, chemistry and material sciences, where particles represent atoms or molecules, the method is called molecular dynamics. It often uses periodic boundary conditions avoiding strong boundary effects, and attach thermo- and bariostates (s.a. [Nosé-Hoover thermostat](http://en.wikipedia.org/wiki/Nos%C3%A9%E2%80%93Hoover_thermostat)) in order to simulate the constant temperature and, or constant pressure ensemble. Some interesting simulations and can be found on youtube, such as: a simulation of [water vaporing (annoying sound)](https://www.youtube.com/watch?v=B3cXuisH8PI) and [melting ice](https://www.youtube.com/watch?v=6s0b_keOiOU).

Finally the method is applied in computer graphics in order to simulate explosions, the [flow of water](https://www.youtube.com/watch?v=Qve54Z71VYU), smoke and [many more](https://www.youtube.com/watch?v=x8Fo2slT2WA).

The implementation is motivated by [GPU Gems 3](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch31.html) and shows how
you can solve a gravitational n-body system and display the bodies positions using [OpenGL](https://www.opengl.org/) respectively [OpenTK](http://www.opentk.com/).

In order to compare, you might download a C++ implementation from the [NVIDIA CUDA samples](http://docs.nvidia.com/cuda/cuda-samples/#cuda-n-body-simulation).

# Approximations

Parallelization is done at the particle level and forces are calculated between all pairs of particles, in contrast to simulations which approximate 
the force between pairs of distant particles using mean field approches, which reduce the complexity from $O(n^2)$.

The gravitational force on particle $i$ is:

$$$
\begin{equation}
    F_{i} = \sum_{1 \leq j \leq N, i \neq j} f_{ij} = G m_i \sum_{1 \leq j \leq N, i \neq j} \frac{m_j r_{ij} }{{\left||r_{ij}\right|| }^3},
\end{equation}

where $m_i$ and $m_j$ are the masses of bodies $i$ resp. $j$; $r_{ij}=x_i-x_j$ and $G$ is the gravitational constant.

We add a softening constant $\varepsilon$, which limits the amount of force two particles can exert on each other. This is especially important as integration is done using finite time steps and hence particles can come closer than they would otherwise. Further 
more it also makes the discrimination between the case $i = j$ and $i \neq j$ obsolete.

The force then becomes:

$$$
\begin{equation}
F_{i} \approx  \sum_{1 \leq j \leq N} G \frac{r_{ij} m_j m_i}{{\sqrt{\left||r_{ij}\right||^2 + \varepsilon^2} }^3}.
\end{equation}

Newton's equations imply conservation of energy, momentum and angular momentum. Using the wrong scheme for numerical integration (or too big time steps) however destroys these conservation laws. Integration schemes that preserve the conservation laws are the [simplectic integrators](http://en.wikipedia.org/wiki/Symplectic_integrator), e.g. [verlet](http://en.wikipedia.org/wiki/Verlet_integration) and the [velocity verlet](http://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet) algorithm. Following NVIDIA’s example however we use the following integration scheme including a damping term $<0$, reducing the energy slightly in every integration step:

$$$
\begin{equation}v_{t+dt} = \rm{damping} \left(v_t + a_t dt\right) \\
x_{t+dt} = x_{t} + v_{t+dt} dt
\end{equation}

# Implementation

We give three implementations of the simulation:

- a simple CPU implementation
- a GPU implementation with dynamic `blockSize`
- a GPU implementation with static `blockSize`

In addition we implemented a class `SimWindow` which visualizes the simulation using [OpenTK](http://www.opentk.com/).